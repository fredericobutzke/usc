:fsm controller

:in (Lreq Rack LEack REreq Err1 Err0 a b)
:out (Lack Rreq LEreq REack clk sample)

:init-in (Lreq~ Rack~ LEack~ REreq~ Err1~ Err0~  a~ b~)
:init-out (Lack~ Rreq~ LEreq~ REack~ clk~ sample~ )

:init-state 0

:state 0  	( Lreq 			) 						1  	( LEreq )
:state 1	( LEack			)						2	( clk * Rreq )
:state 2	( REreq			)						3	( sample )
:state 3	( Err0			)						4	( clk~ * Lack )
:state 3	( Err1			)						5	( clk~ * Lack )
:state 4	( a				)						6	( sample~ * REack )
:state 4	( a * Lreq~		)						7	( sample~ * REack * LEreq~ )
:state 5	( b				)						8	( sample~ * REack )
:state 5	( b * Lreq~		)						9	( sample~ * REack * LEreq~ )
:state 6	( Err0~ * a~		)					10 	( )
:state 6	( Err0~ * a~ * Lreq~ )					11 	( LEreq~ )
:state 7	( Err0~ * a~		)					11 	( )
:state 7	( Err0~ * a~ * LEack~ )					12 	( clk * Rreq~ )
:state 8	( Err1~ * b~		)					10 	( )
:state 8	( Err1~ * b~ * Lreq~	)				11 	( LEreq~ )
:state 9	( Err1~ * b~ 	)						11 	( )
:state 9	( Err1~ * b~ * LEack~ )					12 	( clk * Rreq~ )
:state 10	( Rack			)						13 	( )
:state 10	( Rack * Lreq~	)						14 	( LEreq~ )
:state 11	( Rack			)						14 	( )
:state 11	( Rack * LEack~	)						15 	( clk * Rreq~ )
:state 12	( Rack 			)						15 	( )
:state 12	( Rack * REreq~	)						16 	( sample )
:state 13 	( Lreq~ 			) 					14 	( LEreq~ )
:state 14	( LEack~			)					15 	( clk * Rreq~ )
:state 15	( REreq~			)					16 	( sample )
:state 16	( Err0			)						17 	( clk~ * Lack~ )
:state 16	( Err1			)						18 	( clk~ * Lack~ )
:state 17	( a				)						19 	( sample~ * REack~ )
:state 17	( a * Lreq		)						20 	( sample~ * REack~ * LEreq )
:state 18	( b				)						21 	( sample~ * REack~ )
:state 18	( b * Lreq		)						22 	( sample~ * REack~ * LEreq )
:state 19	( Err0~ * a~		)					23 	( )
:state 19	( Err0~ * a~ * Lreq	)					24 	( LEreq )
:state 20	( Err0~ * a~		)					24 	( )
:state 20	( Err0~ * a~ * LEack	)				25 	( clk * Rreq )
:state 21	( Err1~ * b~		)					23 	( )
:state 21	( Err1~ * b~ * Lreq	)					24 	( LEreq )
:state 22	( Err1~ * b~ 	)						24 	( )
:state 22	( Err1~ * b~ * LEack	)				25 	( clk * Rreq )
:state 23	( Rack~			)						0	( )
:state 23	( Rack~ * Lreq	)						1	( LEreq )
:state 24	( Rack~			)						1	( )
:state 24	( Rack~ * LEack	)						2	( clk * Rreq )
:state 25	( Rack~ 		)						2	( )
:state 25	( Rack~ * REreq	)						3	( sample )